#define _CRT_SECURE_NO_WARNINGS

#define pi 3.141592
#define e 2.718281

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <ctype.h>

#define MAX 100

void save(const char* operation, float result);
void show(void);
void reset(void);
double applyOperation(double, double, char);
double evaluateExpression(char*);
double fetchFromHistory(int index);
void applications(void);

// توابع ریاضیاتی و مثلثاتی
double add(double a, double b) { return a + b; }
double subtract(double a, double b) { return a - b; }
double multiply(double a, double b) { return a * b; }
double divide(double a, double b) {
    if (b != 0) return a / b;
    printf("Error: Division by zero is not allowed.\n");
    return 0;
}
double sine(double x) { return sin(x); }
double cosine(double x) { return cos(x); }
double tangent(double x) { return tan(x); }
double cotangent(double x) { return 1.0 / tan(x); }
double logarithm(double x) { return log(x); }
double power(double base, double exp) { return pow(base, exp); }
double squareroot(double x) { return sqrt(x); }

// توابع کمکی
int precedence(char operator) {
    if (operator == '+' || operator == '-') return 1;
    if (operator == '*' || operator == '/') return 2;
    if (operator == '^') return 3;
    return 0;
}

double applyOperator(double a, double b, char operator) {
    switch (operator) {
        case '+': return add(a, b);
        case '-': return subtract(a, b);
        case '*': return multiply(a, b);
        case '/': return divide(a, b);
        case '^': return power(a, b);
        default: return 0;
    }
}

double applyFunction(double x, const char* func) {
    if (strcmp(func, "sin") == 0) return sine(x);
    if (strcmp(func, "cos") == 0) return cosine(x);
    if (strcmp(func, "tan") == 0) return tangent(x);
    if (strcmp(func, "cot") == 0) return cotangent(x);
    if (strcmp(func, "log") == 0) return logarithm(x);
    if (strcmp(func, "sqrt") == 0) return squareroot(x);
    return 0;
}

// تابع برای ارزیابی عبارت
double evaluateExpression(char* expression) {
    double values[MAX]; // پشته مقادیر
    char operators[MAX]; // پشته عملگرها
    int valuesIndex = -1;
    int operatorsIndex = -1;
    char func[10];
    int funcIndex = 0;

    for (int i = 0; i < strlen(expression); i++) {
        if (isdigit(expression[i])) {
            double value = 0;
            while (i < strlen(expression) && (isdigit(expression[i]) || expression[i] == '.')) {
                if (expression[i] == '.') {
                    i++;
                    double decimal = 1;
                    while (i < strlen(expression) && isdigit(expression[i])) {
                        decimal /= 10;
                        value += (expression[i] - '0') * decimal;
                        i++;
                    }
                } else {
                    value = (value * 10) + (expression[i] - '0');
                    i++;
                }
            }
            values[++valuesIndex] = value;
            i--;
        } else if (expression[i] == '(') {
            if (funcIndex > 0) {
                func[funcIndex] = '\0';
                operators[++operatorsIndex] = '(';
                values[++valuesIndex] = applyFunction(evaluateExpression(expression + i + 1), func);
                while (expression[i] != ')') i++;
                funcIndex = 0;
            } else {
                operators[++operatorsIndex] = expression[i];
            }
        } else if (expression[i] == ')') {
            while (operatorsIndex != -1 && operators[operatorsIndex] != '(') {
                double b = values[valuesIndex--];
                double a = values[valuesIndex--];
                char operator = operators[operatorsIndex--];
                values[++valuesIndex] = applyOperator(a, b, operator);
            }
            operatorsIndex--; // حذف پرانتز باز
        } else if (precedence(expression[i]) > 0) {
            while (operatorsIndex != -1 && precedence(operators[operatorsIndex]) >= precedence(expression[i])) {
                double b = values[valuesIndex--];
                double a = values[valuesIndex--];
                char operator = operators[operatorsIndex--];
                values[++valuesIndex] = applyOperator(a, b, operator);
            }
            operators[++operatorsIndex] = expression[i];
        } else if (isalpha(expression[i])) {
            func[funcIndex++] = expression[i];
        }
    }

    while (operatorsIndex != -1) {
        double b = values[valuesIndex--];
        double a = values[valuesIndex--];
        char operator = operators[operatorsIndex--];
        values[++valuesIndex] = applyOperator(a, b, operator);
    }

    return values[0];
}

void applications() {
    char expression[100];
    double result;

    while (1) {
        printf("Enter a calculation: ");
        fgets(expression, sizeof(expression), stdin);

        for (int i = 0; expression[i] != '\0'; i++) {
            if (expression[i] == '\n') {
                expression[i] = '\0';
                break;
            }
        }

        if (expression[0] == 'n' || expression[0] == 'N') {
            printf("Now returning to the menu...\n");
            return;
        } else if (expression[0] == 'c' || expression[0] == 'C') {
            reset();
        } else {
            char* hashPos = strchr(expression, '#');
            while (hashPos != NULL) {
                int index;
                sscanf(hashPos + 1, "%d", &index);
                double historyValue = fetchFromHistory(index);

                // Find the position after the number in the expression
                char* restOfExpression = hashPos + 1;
                while (isdigit(*restOfExpression)) restOfExpression++;

                // Create a temporary buffer to hold the new expression
                char tempExpression[100];
                snprintf(tempExpression, sizeof(tempExpression), "%.2f%s", historyValue, restOfExpression);

                // Copy the temporary buffer back to the original expression
                strcpy(hashPos, tempExpression);

                // Find the next occurrence of '#'
                hashPos = strchr(hashPos + 1, '#');
            }
        }

        result = evaluateExpression(expression);
        printf("Result: %.2lf\n", result);
        save(expression, (float)result);
    }
}

int main() {
    int choice;
    printf("Choose an option:\n1. Hints\n2. Calculator\n3. Show History\n4. Reset History\n5. Exit\n");

    while (1) {
        scanf("%d", &choice);
        getchar();

        switch (choice) {
        case 1:
            printf("Hints are not implemented yet.\n");
            break;
        case 2:
            applications();
            break;
        case 3:
            show();
            break;
        case 4:
            reset();
            break;
        case 5:
            printf("Exiting...\n");
            exit(1);
        default:
            printf("Invalid number!\n");
        }
    }
    return 0;
}

void save(const char* operation, float result) {
    FILE* fp = fopen("data_saver.txt", "a");
    if (fp == NULL) return;
    fprintf(fp, "%s = %.2f\n", operation, result);
    fclose(fp);
}

void show(void) {
    FILE* fp = fopen("data_saver.txt", "r");
    char line[200];
    int index = 1;

    if (fp == NULL) {
        printf("Nothing in history\n");
        return;
    }

    while (fgets(line, sizeof(line), fp) != NULL) {
        printf("#%d: %s", index++, line);
    }

    fclose(fp);
}

void reset(void) {
    FILE* fp = fopen("data_saver.txt", "w");
    fclose(fp);
    printf("The history has been cleared\n");
}

double fetchFromHistory(int index) {
    FILE* fp = fopen("data_saver.txt", "r");
    char line[200];
    int currentIndex = 1;

    if (fp == NULL) {
        printf("History is empty.\n");
        return 0;
    }

    while (fgets(line, sizeof(line), fp) != NULL) {
        if (currentIndex == index) {
            char* equalSign = strchr(line, '=');
            if (equalSign != NULL) {
                fclose(fp);
                return atof(equalSign + 2); // Extract the value after '='
            }
        }
        currentIndex++;
    }

    fclose(fp);
    printf("Invalid history number!\n");
    return 0;
}
